###############################################
#### Steps to compile and run the executable###
###############################################

cd ordermanagement
mkdir build
cmake . -B build
cd build
make
./OrderManagement



###############################################################
#### Some information about the solution components/design ####
###############################################################

Config class -  Provides basic config file parsing functionality to read configuration parameters from a file.
                Config file supports trading open/close times in HH:MM:SS am/pm format
                (to represent this in the code, I use offsets from current day begin).
                Config file also supports throttling rate, sliding window size in seconds,
                username/password parameter to login to the exchange.
                I use simple paramName=paramValue format in the config, as I am not allowed
                to use third party libraries to work with more widespread config file formats (e.g. XML).
                I am also assuming that the time range covered by open/close times does not cross the midnight
                in UTC timezone (i.e. trading can't open at 9pm today and close at 4am tomorrow,
                however it can open at 9am today and close at 4pm today).
                I understand that there are exchanges that trade 23 hours a day (e.g. CME), but for the sake of
                simplicity I am doing this assumption.

Utils       -   Contains definitions of basic structs provided by the exercise

OrderManagement class - This is the main class that performs order management and exchange transmission rate limiting.
                        On a high level there are 2 threads working with orders, one that writes orders to a queue
                        and another one that reads from the queue and transmits orders to the exchange, with appropriate
                        pre configured rate limiting. There is also another thread that periodically checks the time
                        and sends login/logout requests to the exchange and sets m_exchangeOpen flag,
                        indicating whether orders need to be processed or rejected by OrderManagement.
                        Note that this thread uses relatively long sleeps when exchange open/close times are far away
                        from the current time, however when exchange open/close times get closer to the current time,
                        this thread performs a busy wait, to start transmitting orders instantly when exchange opens.
                        Given the requirements of this exercise, I think there is no need for us to keep orders in the
                        queue once they have been transmitted to the exchange. This is because we only care about
                        order statistics information after that, so we can just save per order stats in some data structure
                        after order transmission to the exchange (to match it with its response and to calculate order
                        roundTrip latency and other stats).
                        I think that order wait time in a queue, can also be a nice indicator of overall system performance.
                        That's why I calculate 2 latency stats per order, order wait time in the queue and
                        time between orders transmission and its response receival.


MockOrdersGenerator class - Provides pseudo random, dummy, new/modify/cancel orders generation functionality
                            and submits orders to OrderManagement instance it receives in constructor.
                            Multiple instances of this class can be instantiated with the same OrderManagement
                            class instance, to simulate multithreaded orders submission to OrderManagement.
                            This MockOrdersGenerator class is an attempt to simulate multithreaded flow for testing
                            (every MockOrdersGenerator instance submits orders to OrderManagement in a separate thread).
                            Every instance of this class generates sequential orders but also prepends unique digit
                            (clientPrefix digit it receives in its constructor), so that we can easily distinguish
                            between orders from different generators (OrderIds of MockOrdersGenerator1 will start with 1,
                            OrderIds generated by MockOrdersGenerator2 will start with digit 2 etc.).


IExchangeSimulator/ExchangeResponseSimulator classes - Simulates exchange functionality. It receives orders from OrderManagement and calls callbacks to report
                                                       responses for every order. IExchangeSimulator provides interface of an Exchange and ExchangeResponseSimulator
                                                       implements a mock exchange for testing (note: I use dependency injection for this project components testing).

OrderStatsFileWriterCallback/OrderStatsCollector classes - IOrderStatsCollectorCallBack provides abstract interface to receive order stats information.
                                                           Clients can implement this interface to receive order stats information. As exercise requires us
                                                           to only write collected stats in persistent storage, OrderStatsFileWriterCallback class
                                                           implements this interface and writes received latency information to a file.
                                                           Note that if other components/classes in the trading system, needed to receive order stats information,
                                                           we could easily change the design to register listeners and broadcast this information to other interested
                                                           parties.



#################################################################################################
#### A couple of words on overall implementation and optimisation potential of this solution ####
#################################################################################################

As I mentioned above I am assuming that all onData calls can be performed by multiple threads (both from client/strategy side as well as from the exchange side).
This means that we need to lock accesses to the shared resources, like orders cache/stats map etc.
I use standard C++ tools to synchronise multithreaded reads vs writes in the implementation.

We could try to use lock free queues to make this engine more performant, avoid using allocations on a hot path
(e.g. we could use a custom allocators to avoid system calls/memory allocations for the queue, when we need to cache too many
orders because of the rate limiting). I used atomic variables that on their own can slow things up a little and disable some
of the compiler optimisations (we could consider using at least relaxed atomics). I didn't use a ring buffers for a queue,
to not limit number of orders that we can store in the cache.
